"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeTokenMint = exports.createAccountsMintsAndTokenAccounts = void 0;
const web3_js_1 = require("@solana/web3.js");
const keypair_1 = require("./keypair");
const spl_token_1 = require("@solana/spl-token");
const transaction_1 = require("./transaction");
const spl_token_metadata_1 = require("@solana/spl-token-metadata");
const TOKEN_PROGRAM = spl_token_1.TOKEN_2022_PROGRAM_ID;
// Create users, mints, create ATAs and mint tokens.
// TODO: we may actually want to split this into multiple transactions
// to avoid the transaction size limit (or use lookup tables)
// in the future. However it works for two transactions of the size
// used in our unit tests.
const createAccountsMintsAndTokenAccounts = async (usersAndTokenBalances, lamports, connection, payer) => {
    const userCount = usersAndTokenBalances.length;
    // Set the variable mintCount to the largest array in the usersAndTokenBalances array
    const mintCount = Math.max(...usersAndTokenBalances.map((mintBalances) => mintBalances.length));
    const users = (0, keypair_1.makeKeypairs)(userCount);
    const mints = (0, keypair_1.makeKeypairs)(mintCount);
    // This will be returned
    // [user index][mint index]address of token account
    let tokenAccounts;
    tokenAccounts = users.map((user) => {
        return mints.map((mint) => (0, spl_token_1.getAssociatedTokenAddressSync)(mint.publicKey, user.publicKey, false, TOKEN_PROGRAM));
    });
    const sendSolInstructions = users.map((user) => web3_js_1.SystemProgram.transfer({
        fromPubkey: payer.publicKey,
        toPubkey: user.publicKey,
        lamports,
    }));
    // Airdrops to user
    const minimumLamports = await (0, spl_token_1.getMinimumBalanceForRentExemptMint)(connection);
    const createMintInstructions = mints.map((mint) => web3_js_1.SystemProgram.createAccount({
        fromPubkey: payer.publicKey,
        newAccountPubkey: mint.publicKey,
        lamports: minimumLamports,
        space: spl_token_1.MINT_SIZE,
        programId: TOKEN_PROGRAM,
    }));
    // Make tokenA and tokenB mints, mint tokens and create ATAs
    const mintTokensInstructions = usersAndTokenBalances.flatMap((userTokenBalances, userIndex) => {
        return userTokenBalances.flatMap((tokenBalance, mintIndex) => {
            if (tokenBalance === 0) {
                return [];
            }
            return makeMintInstructions(mints[mintIndex].publicKey, tokenAccounts[userIndex][mintIndex], tokenBalance, users[userIndex].publicKey, payer.publicKey);
        });
    });
    const instructions = [
        ...sendSolInstructions,
        ...createMintInstructions,
        ...mintTokensInstructions,
    ];
    const signers = [...users, ...mints, payer];
    // Finally, make the transaction and send it.
    await makeAndSendAndConfirmTransaction(connection, instructions, signers, payer);
    return {
        users,
        mints,
        tokenAccounts,
    };
};
exports.createAccountsMintsAndTokenAccounts = createAccountsMintsAndTokenAccounts;
const makeTokenMint = async (connection, mintAuthority, name, symbol, decimals, uri, additionalMetadata = [], updateAuthority = mintAuthority.publicKey, freezeAuthority = null) => {
    const mint = web3_js_1.Keypair.generate();
    if (!Array.isArray(additionalMetadata)) {
        additionalMetadata = Object.entries(additionalMetadata);
    }
    const addMetadataInstructions = additionalMetadata.map((additionalMetadataItem) => {
        return (0, spl_token_metadata_1.createUpdateFieldInstruction)({
            metadata: mint.publicKey,
            updateAuthority: updateAuthority,
            programId: spl_token_1.TOKEN_2022_PROGRAM_ID,
            field: additionalMetadataItem[0],
            value: additionalMetadataItem[1],
        });
    });
    const metadata = {
        mint: mint.publicKey,
        name,
        symbol,
        uri,
        additionalMetadata,
    };
    // Work out how much SOL we need to store our Token
    const mintLength = (0, spl_token_1.getMintLen)([spl_token_1.ExtensionType.MetadataPointer]);
    const metadataLength = spl_token_1.TYPE_SIZE + spl_token_1.LENGTH_SIZE + (0, spl_token_metadata_1.pack)(metadata).length;
    const mintLamports = await connection.getMinimumBalanceForRentExemption(mintLength + metadataLength);
    const mintTransaction = new web3_js_1.Transaction().add(
    // Create Account
    web3_js_1.SystemProgram.createAccount({
        fromPubkey: mintAuthority.publicKey,
        newAccountPubkey: mint.publicKey,
        space: mintLength,
        lamports: mintLamports,
        programId: spl_token_1.TOKEN_2022_PROGRAM_ID,
    }), 
    // Initialize metadata pointer (so the mint points to itself for metadata)
    (0, spl_token_1.createInitializeMetadataPointerInstruction)(mint.publicKey, mintAuthority.publicKey, mint.publicKey, spl_token_1.TOKEN_2022_PROGRAM_ID), 
    // Initialize mint
    (0, spl_token_1.createInitializeMintInstruction)(mint.publicKey, decimals, mintAuthority.publicKey, freezeAuthority, spl_token_1.TOKEN_2022_PROGRAM_ID), 
    // Initialize
    (0, spl_token_1.createInitializeInstruction)({
        programId: spl_token_1.TOKEN_2022_PROGRAM_ID,
        mint: mint.publicKey,
        metadata: mint.publicKey,
        name: metadata.name,
        symbol: metadata.symbol,
        uri: metadata.uri,
        mintAuthority: mintAuthority.publicKey,
        updateAuthority: updateAuthority,
    }), 
    // Update field (actually used to add a custom field)
    // See https://github.com/solana-labs/solana-program-library/blob/master/token/js/examples/metadata.ts#L81C6-L81C6
    // Must come last!
    ...addMetadataInstructions);
    const signature = await (0, web3_js_1.sendAndConfirmTransaction)(connection, mintTransaction, [mintAuthority, mint]);
    return mint.publicKey;
};
exports.makeTokenMint = makeTokenMint;
// Just a non-exposed helper function to create all the instructions instructions
// needed for creating a mint, creating an ATA, and minting tokens to the ATA
// TODO: maybe we should expose this? To discuss.
const makeMintInstructions = (mintAddress, ataAddress, amount, authority, payer = authority) => {
    return [
        // Initializes a new mint and optionally deposits all the newly minted tokens in an account.
        (0, spl_token_1.createInitializeMint2Instruction)(mintAddress, 6, authority, null, TOKEN_PROGRAM),
        // Create the ATA
        (0, spl_token_1.createAssociatedTokenAccountIdempotentInstruction)(payer, ataAddress, authority, mintAddress, TOKEN_PROGRAM),
        // Mint some tokens to the ATA
        (0, spl_token_1.createMintToInstruction)(mintAddress, ataAddress, authority, amount, [], TOKEN_PROGRAM),
    ];
};
// Send a versioned transaction with less boilerplate
// https://www.quicknode.com/guides/solana-development/transactions/how-to-use-versioned-transactions-on-solana
// TODO: maybe we should expose this? To discuss.
const makeAndSendAndConfirmTransaction = async (connection, instructions, signers, payer) => {
    const latestBlockhash = (await connection.getLatestBlockhash("max"))
        .blockhash;
    const messageV0 = new web3_js_1.TransactionMessage({
        payerKey: payer.publicKey,
        recentBlockhash: latestBlockhash,
        instructions,
    }).compileToV0Message();
    const transaction = new web3_js_1.VersionedTransaction(messageV0);
    transaction.sign(signers);
    const signature = await connection.sendTransaction(transaction);
    await (0, transaction_1.confirmTransaction)(connection, signature);
};
//# sourceMappingURL=token.js.map